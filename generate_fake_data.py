from app import db
from app.models import Case,Start,End,A,B,C,D
from datetime import datetime
from random import randint

MIN_START_YEAR = 2011
MAX_END_YEAR = 2020 #dates in the future are considered still in progress of being completed, so they will change over time

def generate_firstname():
    first_names = ["John","Charlie","Bob","Rick","Steven","Eric","Alex","Rachel","Sarah","Margie","Maggie","Albert","Christine","Christina"]
    return first_names[randint(0,len(first_names)-1)]

def generate_lastname():
    last_names = ["Johnson","Harding","Phillips","Stevens","Richardson","Archer","Black","Brown","Steele","Powers"]
    return last_names[randint(0,len(last_names)-1)]

def start_end_semantic_consistency(min_num_days_for_process = 15):
    start_date = datetime(randint(MIN_START_YEAR,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
    end_date = datetime(randint(MIN_START_YEAR,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
    diff = end_date - start_date
    if diff.days > min_num_days_for_process:
        return start_date,end_date
    else:
        while diff.days < min_num_days_for_process:
            start_date = datetime(randint(MIN_START_YEAR,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
            end_date = datetime(randint(MIN_START_YEAR,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
            diff = end_date - start_date
        return start_date,end_date

def date_generation_for_internal_nodes(start_date,end_date,min_num_days_for_process=2):
    date_started = datetime(randint(start_date.year,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
    date_completed = datetime(randint(MIN_START_YEAR,end_date.year),randint(1,12),randint(1,28),1,1)
    diff = end_date - start_date
    if diff.days > min_num_days_for_process:
        return start_date,end_date
    else:
        while diff.days < min_num_days_for_process:
            date_started = datetime(randint(start_date.year,MAX_END_YEAR),randint(1,12),randint(1,28),1,1)
            date_completed = datetime(randint(MIN_START_YEAR,end_date.year),randint(1,12),randint(1,28),1,1)
            diff = date_completed - date_started
        return date_started,date_completed

def generate_data(num_entities):    
    tables = [A,B,C,D]
    db_elements = []

    #I had to break things up this way because the id is autogenerated after being commited to the DB
    for i in xrange(num_entities):
        first_name = generate_firstname()
        last_name = generate_lastname()
        name = first_name + " " + last_name
        email = first_name+last_name+"@gmail.com"
        db_elements.append(Case(name,email))
        [db.session.add(elem) for elem in db_elements]
        db.session.commit()

    db_elements = []
    cases = Case.query.all()
    for i in xrange(num_entities):
        case = cases[i] #purely for readability
        start_date,end_date = start_end_semantic_consistency()
        db_elements.append(Start(start_date,case.id))
        db_elements.append(End(end_date,case.id))
        for table in tables:
            for i in xrange(randint(5,50)):
                date_started,date_completed = date_generation_for_internal_nodes(start_date,end_date) 
                db_elements.append(table(date_started,date_completed,case.id))
        [db.session.add(elem) for elem in db_elements] 
        db.session.commit()

if __name__ == '__main__':
    generate_data(30)
